\href{https://standardjs.com}{\texttt{ }}

A Node.\+js file system walker extracted from \href{https://github.com/jprichardson/node-fs-extra}{\texttt{ fs-\/extra}}.

\href{https://www.npmjs.org/package/klaw}{\texttt{ }} \href{http://travis-ci.org/jprichardson/node-klaw}{\texttt{ }} \href{https://ci.appveyor.com/project/jprichardson/node-klaw/branch/master}{\texttt{ }}\hypertarget{md_node_modules_klaw_README_autotoc_md634}{}\doxysection{Install}\label{md_node_modules_klaw_README_autotoc_md634}
\begin{DoxyVerb}npm i --save klaw
\end{DoxyVerb}


If you\textquotesingle{}re using Typescript, we\textquotesingle{}ve got \href{https://github.com/DefinitelyTyped/DefinitelyTyped/pull/11492/files}{\texttt{ types}}\+: \begin{DoxyVerb}npm i --save-dev @types/klaw
\end{DoxyVerb}
\hypertarget{md_node_modules_klaw_README_autotoc_md635}{}\doxysection{Name}\label{md_node_modules_klaw_README_autotoc_md635}
{\ttfamily klaw} is {\ttfamily walk} backwards \+:p\hypertarget{md_node_modules_klaw_README_autotoc_md636}{}\doxysection{Sync}\label{md_node_modules_klaw_README_autotoc_md636}
If you need the same functionality but synchronous, you can use \href{https://github.com/manidlou/node-klaw-sync}{\texttt{ klaw-\/sync}}.\hypertarget{md_node_modules_klaw_README_autotoc_md637}{}\doxysection{Usage}\label{md_node_modules_klaw_README_autotoc_md637}
\hypertarget{md_node_modules_klaw_README_autotoc_md638}{}\doxysubsection{klaw(directory, \mbox{[}options\mbox{]})}\label{md_node_modules_klaw_README_autotoc_md638}
Returns a \href{https://nodejs.org/api/stream.html\#stream_class_stream_readable}{\texttt{ Readable stream}} that iterates through every file and directory starting with {\ttfamily dir} as the root. Every {\ttfamily read()} or {\ttfamily data} event returns an object with two properties\+: {\ttfamily path} and {\ttfamily stats}. {\ttfamily path} is the full path of the file and {\ttfamily stats} is an instance of \href{https://nodejs.org/api/fs.html\#fs_class_fs_stats}{\texttt{ fs.\+Stats}}.


\begin{DoxyItemize}
\item {\ttfamily directory}\+: The directory to recursively walk. Type {\ttfamily string}.
\item {\ttfamily options}\+: \href{https://nodejs.org/api/stream.html\#stream_new_stream_readable_options}{\texttt{ Readable stream options}} and the following\+:
\begin{DoxyItemize}
\item {\ttfamily queue\+Method} ({\ttfamily string}, default\+: `\textquotesingle{}shift'{\ttfamily )\+: Either}\textquotesingle{}shift\textquotesingle{}{\ttfamily or}\textquotesingle{}pop\textquotesingle{}{\ttfamily . On}readdir(){\ttfamily array, call either}shift(){\ttfamily or}pop(){\ttfamily . -\/}path\+Sorter{\ttfamily (}function{\ttfamily , default\+:}undefined{\ttfamily )\+: Sorting \mbox{[}function for Arrays\mbox{]}(\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort}{\texttt{ https\+://developer.\+mozilla.\+org/en-\/\+U\+S/docs/\+Web/\+Java\+Script/\+Reference/\+Global\+\_\+\+Objects/\+Array/sort}}). -\/}fs{\ttfamily (}object{\ttfamily , default\+: \mbox{[}}graceful-\/fs{\ttfamily \mbox{]}(\href{https://github.com/isaacs/node-graceful-fs}{\texttt{ https\+://github.\+com/isaacs/node-\/graceful-\/fs}}))\+: Use this to hook into the}fs{\ttfamily methods or to use \mbox{[}}mock-\/fs{\ttfamily \mbox{]}(\href{https://github.com/tschaub/mock-fs}{\texttt{ https\+://github.\+com/tschaub/mock-\/fs}}) -\/}filter{\ttfamily (}function{\ttfamily , default\+:}undefined{\ttfamily )\+: Filtering \mbox{[}function for Arrays\mbox{]}(\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter}{\texttt{ https\+://developer.\+mozilla.\+org/en-\/\+U\+S/docs/\+Web/\+Java\+Script/\+Reference/\+Global\+\_\+\+Objects/\+Array/filter}}) -\/}depth\+Limit{\ttfamily (}number{\ttfamily , default\+:}undefined{\ttfamily )\+: The number of times to recurse before stopping. -\/1 for unlimited. -\/}preserve\+Symlinks{\ttfamily (}boolean{\ttfamily , default\+:}false\`{})\+: Whether symlinks should be followed or treated as items themselves. If true, symlinks will be returned as items in their own right. If false, the linked item will be returned and potentially recursed into, in its stead.
\end{DoxyItemize}
\end{DoxyItemize}

{\bfseries{Streams 1 (push) example\+:}}


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const} klaw = require(\textcolor{stringliteral}{'klaw'})}
\DoxyCodeLine{}
\DoxyCodeLine{const items = [] \textcolor{comment}{// files, directories, symlinks, etc}}
\DoxyCodeLine{klaw('/some/dir')}
\DoxyCodeLine{  .on('data', item => items.push(item.path))}
\DoxyCodeLine{  .on('end', () => console.dir(items)) \textcolor{comment}{// => [ ... array of files]}}
\end{DoxyCode}


{\bfseries{Streams 2 \& 3 (pull) example\+:}}


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const} klaw = require(\textcolor{stringliteral}{'klaw'})}
\DoxyCodeLine{}
\DoxyCodeLine{const items = [] \textcolor{comment}{// files, directories, symlinks, etc}}
\DoxyCodeLine{klaw('/some/dir')}
\DoxyCodeLine{  .on('readable', function () \{}
\DoxyCodeLine{    let item}
\DoxyCodeLine{    \textcolor{keywordflow}{while} ((item = this.read())) \{}
\DoxyCodeLine{      items.push(item.path)}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \})}
\DoxyCodeLine{  .on(\textcolor{stringliteral}{'end'}, () => console.dir(items)) \textcolor{comment}{// => [ ... array of files]}}
\end{DoxyCode}
\hypertarget{md_node_modules_klaw_README_autotoc_md639}{}\doxysubsection{Error Handling}\label{md_node_modules_klaw_README_autotoc_md639}
Listen for the {\ttfamily error} event.

Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const} klaw = require(\textcolor{stringliteral}{'klaw'})}
\DoxyCodeLine{}
\DoxyCodeLine{klaw('/some/dir')}
\DoxyCodeLine{  .on('readable', function () \{}
\DoxyCodeLine{    let item}
\DoxyCodeLine{    \textcolor{keywordflow}{while} ((item = this.read())) \{}
\DoxyCodeLine{      \textcolor{comment}{// do something with the file}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \})}
\DoxyCodeLine{  .on(\textcolor{stringliteral}{'error'}, (err, item) => \{}
\DoxyCodeLine{    console.log(err.message)}
\DoxyCodeLine{    console.log(item.path) \textcolor{comment}{// the file the error occurred on}}
\DoxyCodeLine{  \})}
\DoxyCodeLine{  .on(\textcolor{stringliteral}{'end'}, () => console.dir(items)) \textcolor{comment}{// => [ ... array of files]}}
\end{DoxyCode}
\hypertarget{md_node_modules_klaw_README_autotoc_md640}{}\doxysubsection{Aggregation / Filtering / Executing Actions (\+Through Streams)}\label{md_node_modules_klaw_README_autotoc_md640}
On many occasions you may want to filter files based upon size, extension, etc. Or you may want to aggregate stats on certain file types. Or maybe you want to perform an action on certain file types.

You should use the module \href{https://www.npmjs.com/package/through2}{\texttt{ {\ttfamily through2}}} to easily accomplish this.

Install {\ttfamily through2}\+: \begin{DoxyVerb}npm i --save through2
\end{DoxyVerb}


{\bfseries{Example (skipping directories)\+:}}


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const} klaw = require(\textcolor{stringliteral}{'klaw'})}
\DoxyCodeLine{const through2 = require('through2')}
\DoxyCodeLine{}
\DoxyCodeLine{const excludeDirFilter = through2.obj(function (item, enc, next) \{}
\DoxyCodeLine{  \textcolor{keywordflow}{if} (!item.stats.isDirectory()) this.push(item)}
\DoxyCodeLine{  next()}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const} items = [] \textcolor{comment}{// files, directories, symlinks, etc}}
\DoxyCodeLine{klaw(\textcolor{stringliteral}{'/some/dir'})}
\DoxyCodeLine{  .pipe(excludeDirFilter)}
\DoxyCodeLine{  .on(\textcolor{stringliteral}{'data'}, item => items.push(item.path))}
\DoxyCodeLine{  .on(\textcolor{stringliteral}{'end'}, () => console.dir(items)) \textcolor{comment}{// => [ ... array of files without directories]}}
\end{DoxyCode}


{\bfseries{Example (ignore hidden directories)\+:}}


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const} klaw = require(\textcolor{stringliteral}{'klaw'})}
\DoxyCodeLine{const path = require('path')}
\DoxyCodeLine{}
\DoxyCodeLine{const filterFunc = item => \{}
\DoxyCodeLine{  \textcolor{keyword}{const} basename = path.basename(item)}
\DoxyCodeLine{  \textcolor{keywordflow}{return} basename === \textcolor{charliteral}{'.'} || basename[0] !== \textcolor{charliteral}{'.'}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{klaw(\textcolor{stringliteral}{'/some/dir'}, \{ filter: filterFunc \})}
\DoxyCodeLine{  .on(\textcolor{stringliteral}{'data'}, item => \{}
\DoxyCodeLine{    \textcolor{comment}{// only items of none hidden folders will reach here}}
\DoxyCodeLine{  \})}
\end{DoxyCode}


{\bfseries{Example (totaling size of P\+NG files)\+:}}


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const} klaw = require(\textcolor{stringliteral}{'klaw'})}
\DoxyCodeLine{const path = require('path')}
\DoxyCodeLine{const through2 = require('through2')}
\DoxyCodeLine{}
\DoxyCodeLine{let totalPngsInBytes = 0}
\DoxyCodeLine{const aggregatePngSize = through2.obj(function (item, enc, next) \{}
\DoxyCodeLine{  \textcolor{keywordflow}{if} (path.extname(item.path) === \textcolor{stringliteral}{'.png'}) \{}
\DoxyCodeLine{    totalPngsInBytes += item.stats.size}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  this.push(item)}
\DoxyCodeLine{  next()}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{klaw(\textcolor{stringliteral}{'/some/dir'})}
\DoxyCodeLine{  .pipe(aggregatePngSize)}
\DoxyCodeLine{  .on(\textcolor{stringliteral}{'data'}, item => items.push(item.path))}
\DoxyCodeLine{  .on(\textcolor{stringliteral}{'end'}, () => console.dir(totalPngsInBytes)) \textcolor{comment}{// => total of all pngs (bytes)}}
\end{DoxyCode}


{\bfseries{Example (deleting all .tmp files)\+:}}


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const} fs = require(\textcolor{stringliteral}{'fs'})}
\DoxyCodeLine{const klaw = require('klaw')}
\DoxyCodeLine{const through2 = require('through2')}
\DoxyCodeLine{}
\DoxyCodeLine{const deleteAction = through2.obj(function (item, enc, next) \{}
\DoxyCodeLine{  this.push(item)}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordflow}{if} (path.extname(item.path) === \textcolor{stringliteral}{'.tmp'}) \{}
\DoxyCodeLine{    item.deleted = \textcolor{keyword}{true}}
\DoxyCodeLine{    fs.unlink(item.path, next)}
\DoxyCodeLine{  \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{    item.deleted = \textcolor{keyword}{false}}
\DoxyCodeLine{    next()}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const} deletedFiles = []}
\DoxyCodeLine{klaw(\textcolor{stringliteral}{'/some/dir'})}
\DoxyCodeLine{  .pipe(deleteAction)}
\DoxyCodeLine{  .on(\textcolor{stringliteral}{'data'}, item => \{}
\DoxyCodeLine{    \textcolor{keywordflow}{if} (!item.deleted) \textcolor{keywordflow}{return}}
\DoxyCodeLine{    deletedFiles.push(item.path)}
\DoxyCodeLine{  \})}
\DoxyCodeLine{  .on(\textcolor{stringliteral}{'end'}, () => console.dir(deletedFiles)) \textcolor{comment}{// => all deleted files}}
\end{DoxyCode}


You can even chain a bunch of these filters and aggregators together. By using multiple pipes.

{\bfseries{Example (using multiple filters / aggregators)\+:}}


\begin{DoxyCode}{0}
\DoxyCodeLine{klaw(\textcolor{stringliteral}{'/some/dir'})}
\DoxyCodeLine{  .pipe(filterCertainFiles)}
\DoxyCodeLine{  .pipe(deleteSomeOtherFiles)}
\DoxyCodeLine{  .on(\textcolor{stringliteral}{'end'}, () => console.log(\textcolor{stringliteral}{'all done!'}))}
\end{DoxyCode}


{\bfseries{Example passing (piping) through errors\+:}}

Node.\+js does not {\ttfamily pipe()} errors. This means that the error on one stream, like {\ttfamily klaw} will not pipe through to the next. If you want to do this, do the following\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const} klaw = require(\textcolor{stringliteral}{'klaw'})}
\DoxyCodeLine{const through2 = require('through2')}
\DoxyCodeLine{}
\DoxyCodeLine{const excludeDirFilter = through2.obj(function (item, enc, next) \{}
\DoxyCodeLine{  \textcolor{keywordflow}{if} (!item.stats.isDirectory()) this.push(item)}
\DoxyCodeLine{  next()}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const} items = [] \textcolor{comment}{// files, directories, symlinks, etc}}
\DoxyCodeLine{klaw(\textcolor{stringliteral}{'/some/dir'})}
\DoxyCodeLine{  .on(\textcolor{stringliteral}{'error'}, err => excludeDirFilter.emit(\textcolor{stringliteral}{'error'}, err)) \textcolor{comment}{// forward the error on}}
\DoxyCodeLine{  .pipe(excludeDirFilter)}
\DoxyCodeLine{  .on(\textcolor{stringliteral}{'data'}, item => items.push(item.path))}
\DoxyCodeLine{  .on(\textcolor{stringliteral}{'end'}, () => console.dir(items)) \textcolor{comment}{// => [ ... array of files without directories]}}
\end{DoxyCode}
\hypertarget{md_node_modules_klaw_README_autotoc_md641}{}\doxysubsection{Searching Strategy}\label{md_node_modules_klaw_README_autotoc_md641}
Pass in options for {\ttfamily queue\+Method}, {\ttfamily path\+Sorter}, and {\ttfamily depth\+Limit} to affect how the file system is recursively iterated. See the code for more details, it\textquotesingle{}s less than 50 lines \+:)\hypertarget{md_node_modules_klaw_README_autotoc_md642}{}\doxysection{License}\label{md_node_modules_klaw_README_autotoc_md642}
M\+IT

Copyright (c) 2015 \href{https://github.com/jprichardson}{\texttt{ JP Richardson}} 