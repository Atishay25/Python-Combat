\hypertarget{_2home_2atishayjain_2CS251_2Python-Combat_2node_modules_2jsdoc_2lib_2jsdoc_2opts_2argparser_8js-example}{}\doxysection{/home/atishayjain/\+C\+S251/\+Python-\/\+Combat/node\+\_\+modules/jsdoc/lib/jsdoc/opts/argparser.\+js}
Provide information about a legal option.


\begin{DoxyParams}{Parameters}
{\em \{character\}} & short\+Name -\/ The short name of the option, entered like\+: -\/T. \\
\hline
{\em \{string\}} & long\+Name -\/ The equivalent long name of the option, entered like\+: --test. \\
\hline
{\em \{boolean\}} & has\+Value -\/ Does this option require a value? Like\+: -\/t templatename \\
\hline
{\em \{string\}} & help\+Text -\/ A brief description of the option. \\
\hline
{\em \{boolean\}} & \mbox{[}can\+Have\+Multiple=false\mbox{]} -\/ Set to {\ttfamily true} if the option can be provided more than once. \\
\hline
{\em \{function\}} & \mbox{[}coercer\mbox{]} -\/ A function to coerce the given value to a specific type. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\{this\}
\end{DoxyReturn}
my\+Parser.\+add\+Option(\textquotesingle{}t\textquotesingle{}, \textquotesingle{}template\textquotesingle{}, true, \textquotesingle{}The path to the template.\textquotesingle{}); my\+Parser.\+add\+Option(\textquotesingle{}h\textquotesingle{}, \textquotesingle{}help\textquotesingle{}, false, \textquotesingle{}Show the help message.\textquotesingle{});


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const} \_ = require(\textcolor{stringliteral}{'underscore'});}
\DoxyCodeLine{\textcolor{keyword}{const} util = require(\textcolor{stringliteral}{'util'});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const} hasOwnProp = Object.prototype.hasOwnProperty;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{function} padding(length) \{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} \textcolor{keyword}{new} Array(length + 1).join(\textcolor{charliteral}{' '});}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{function} padLeft(str, length) \{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} padding(length) + str;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{function} padRight(str, length) \{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} str + padding(length);}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{function} findMaxLength(arr) \{}
\DoxyCodeLine{    let max = 0;}
\DoxyCodeLine{}
\DoxyCodeLine{    arr.forEach((\{length\}) => \{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (length > max) \{}
\DoxyCodeLine{            max = length;}
\DoxyCodeLine{        \}}
\DoxyCodeLine{    \});}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} max;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{function} concatWithMaxLength(items, maxLength) \{}
\DoxyCodeLine{    let result = \textcolor{stringliteral}{''};}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// to prevent endless loops, always use the first item, regardless of length}}
\DoxyCodeLine{    result += items.shift();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{while} ( items.length \&\& (result.length + items[0].length < maxLength) ) \{}
\DoxyCodeLine{        result += ` \$\{items.shift()\}`;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// we want to format names and descriptions like this:}}
\DoxyCodeLine{\textcolor{comment}{// |    -\/f, -\/-\/foo    Very long description very long description very long    |}}
\DoxyCodeLine{\textcolor{comment}{// |                 description very long description.                       |}}
\DoxyCodeLine{\textcolor{keyword}{function} formatHelpInfo(\{names, descriptions\}) \{}
\DoxyCodeLine{    \textcolor{keyword}{const} MARGIN\_LENGTH = 4;}
\DoxyCodeLine{    \textcolor{keyword}{const} results = [];}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{const} maxLength = process.stdout.columns;}
\DoxyCodeLine{    \textcolor{keyword}{const} maxNameLength = findMaxLength(names);}
\DoxyCodeLine{    \textcolor{keyword}{const} wrapDescriptionAt = maxLength -\/ (MARGIN\_LENGTH * 3) -\/ maxNameLength;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// build the string for each option}}
\DoxyCodeLine{    names.forEach((name, i) => \{}
\DoxyCodeLine{        let result;}
\DoxyCodeLine{        let partialDescription;}
\DoxyCodeLine{        let words;}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// add a left margin to the name}}
\DoxyCodeLine{        result = padLeft(names[i], MARGIN\_LENGTH);}
\DoxyCodeLine{        \textcolor{comment}{// and a right margin, with extra padding so the descriptions line up with one another}}
\DoxyCodeLine{        result = padRight(result, maxNameLength -\/ names[i].length + MARGIN\_LENGTH);}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// split the description on spaces}}
\DoxyCodeLine{        words = descriptions[i].split(\textcolor{charliteral}{' '});}
\DoxyCodeLine{        \textcolor{comment}{// add as much of the description as we can fit on the first line}}
\DoxyCodeLine{        result += concatWithMaxLength(words, wrapDescriptionAt);}
\DoxyCodeLine{        \textcolor{comment}{// if there's anything left, keep going until we've consumed the description}}
\DoxyCodeLine{        \textcolor{keywordflow}{while} (words.length) \{}
\DoxyCodeLine{            partialDescription = padding( maxNameLength + (MARGIN\_LENGTH * 2) );}
\DoxyCodeLine{            partialDescription += concatWithMaxLength(words, wrapDescriptionAt);}
\DoxyCodeLine{            result += `\(\backslash\)n\$\{partialDescription\}`;}
\DoxyCodeLine{        \}}
\DoxyCodeLine{}
\DoxyCodeLine{        results.push(result);}
\DoxyCodeLine{    \});}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} results;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }\mbox{\hyperlink{classArgParser}{ArgParser}} \{}
\DoxyCodeLine{    constructor() \{}
\DoxyCodeLine{        this.\_options = [];}
\DoxyCodeLine{        this.\_shortNameIndex = \{\};}
\DoxyCodeLine{        this.\_longNameIndex = \{\};}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \_getOptionByShortName(name) \{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (hasOwnProp.call(\textcolor{keyword}{this}.\_shortNameIndex, name)) \{}
\DoxyCodeLine{            \textcolor{keywordflow}{return} this.\_options[this.\_shortNameIndex[name]];}
\DoxyCodeLine{        \}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{return} \textcolor{keyword}{null};}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \_getOptionByLongName(name) \{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (hasOwnProp.call(\textcolor{keyword}{this}.\_longNameIndex, name)) \{}
\DoxyCodeLine{            \textcolor{keywordflow}{return} this.\_options[this.\_longNameIndex[name]];}
\DoxyCodeLine{        \}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{return} \textcolor{keyword}{null};}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \_addOption(option) \{}
\DoxyCodeLine{        let currentIndex;}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keyword}{const} longName = option.longName;}
\DoxyCodeLine{        \textcolor{keyword}{const} shortName = option.shortName;}
\DoxyCodeLine{}
\DoxyCodeLine{        this.\_options.push(option);}
\DoxyCodeLine{        currentIndex = this.\_options.length -\/ 1;}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (shortName) \{}
\DoxyCodeLine{            this.\_shortNameIndex[shortName] = currentIndex;}
\DoxyCodeLine{        \}}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (longName) \{}
\DoxyCodeLine{            this.\_longNameIndex[longName] = currentIndex;}
\DoxyCodeLine{        \}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{return} \textcolor{keyword}{this};}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    addOption(shortName, longName, hasValue, helpText, canHaveMultiple = \textcolor{keyword}{false}, coercer) \{}
\DoxyCodeLine{        \textcolor{keywordflow}{return} this.\_addOption(\{}
\DoxyCodeLine{            shortName: shortName,}
\DoxyCodeLine{            longName: longName,}
\DoxyCodeLine{            hasValue: hasValue,}
\DoxyCodeLine{            helpText: helpText,}
\DoxyCodeLine{            canHaveMultiple: canHaveMultiple,}
\DoxyCodeLine{            coercer: coercer}
\DoxyCodeLine{        \});}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// TODO: refactor addOption to accept objects, then get rid of this method}}
\DoxyCodeLine{\textcolor{comment}{}    addIgnoredOption(shortName, longName) \{}
\DoxyCodeLine{        \textcolor{keywordflow}{return} this.\_addOption(\{}
\DoxyCodeLine{            shortName: shortName,}
\DoxyCodeLine{            longName: longName,}
\DoxyCodeLine{            ignore: \textcolor{keyword}{true}}
\DoxyCodeLine{        \});}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    help() \{}
\DoxyCodeLine{        \textcolor{keyword}{const} options = \{}
\DoxyCodeLine{            names: [],}
\DoxyCodeLine{            descriptions: []}
\DoxyCodeLine{        \};}
\DoxyCodeLine{}
\DoxyCodeLine{        this.\_options.forEach(option => \{}
\DoxyCodeLine{            let name = \textcolor{stringliteral}{''};}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// don't show ignored options}}
\DoxyCodeLine{            \textcolor{keywordflow}{if} (option.ignore) \{}
\DoxyCodeLine{                return;}
\DoxyCodeLine{            \}}
\DoxyCodeLine{}
\DoxyCodeLine{            if (option.shortName) \{}
\DoxyCodeLine{                name += `-\/\$\{option.shortName\}\$\{option.longName ? \textcolor{stringliteral}{', '} : \textcolor{stringliteral}{''}\}`;}
\DoxyCodeLine{            \}}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{keywordflow}{if} (option.longName) \{}
\DoxyCodeLine{                name += `-\/-\/\$\{option.longName\}`;}
\DoxyCodeLine{            \}}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{keywordflow}{if} (option.hasValue) \{}
\DoxyCodeLine{                name += \textcolor{stringliteral}{' <value>'};}
\DoxyCodeLine{            \}}
\DoxyCodeLine{}
\DoxyCodeLine{            options.names.push(name);}
\DoxyCodeLine{            options.descriptions.push(option.helpText);}
\DoxyCodeLine{        \});}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{return} `Options:\(\backslash\)n\$\{formatHelpInfo(options).join(\textcolor{charliteral}{'\(\backslash\)n'})\}`;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    parse(args, defaults) \{}
\DoxyCodeLine{        let arg;}
\DoxyCodeLine{        let next;}
\DoxyCodeLine{        let option;}
\DoxyCodeLine{        \textcolor{keyword}{const} result = ( defaults \&\& \_.defaults(\{\}, defaults) ) || \{\};}
\DoxyCodeLine{        let shortName;}
\DoxyCodeLine{        let longName;}
\DoxyCodeLine{        let name;}
\DoxyCodeLine{        let value;}
\DoxyCodeLine{}
\DoxyCodeLine{        result.\_ = [];}
\DoxyCodeLine{        \textcolor{keywordflow}{for} (let i = 0, l = args.length; i < l; i++) \{}
\DoxyCodeLine{            arg = String(args[i]);}
\DoxyCodeLine{            next = (i < l -\/ 1) ? String(args[i + 1]) : \textcolor{keyword}{null};}
\DoxyCodeLine{            shortName = \textcolor{keyword}{null};}
\DoxyCodeLine{            value = \textcolor{keyword}{null};}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{comment}{// like -\/t}}
\DoxyCodeLine{            \textcolor{keywordflow}{if} (arg.charAt(0) === \textcolor{charliteral}{'-\/'}) \{}
\DoxyCodeLine{                \textcolor{comment}{// like -\/-\/template}}
\DoxyCodeLine{                \textcolor{keywordflow}{if} (arg.charAt(1) === \textcolor{charliteral}{'-\/'}) \{}
\DoxyCodeLine{                    name = longName = arg.slice(2);}
\DoxyCodeLine{                    option = this.\_getOptionByLongName(longName);}
\DoxyCodeLine{                \}}
\DoxyCodeLine{                \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{                    name = shortName = arg.slice(1);}
\DoxyCodeLine{                    option = this.\_getOptionByShortName(shortName);}
\DoxyCodeLine{                \}}
\DoxyCodeLine{}
\DoxyCodeLine{                \textcolor{keywordflow}{if} (option === \textcolor{keyword}{null}) \{}
\DoxyCodeLine{                    \textcolor{keywordflow}{throw} \textcolor{keyword}{new} Error( util.format(\textcolor{stringliteral}{'Unknown command-\/line option "\%s".'}, name) );}
\DoxyCodeLine{                \}}
\DoxyCodeLine{}
\DoxyCodeLine{                \textcolor{keywordflow}{if} (option.hasValue) \{}
\DoxyCodeLine{                    value = next;}
\DoxyCodeLine{                    i++;}
\DoxyCodeLine{}
\DoxyCodeLine{                    \textcolor{keywordflow}{if} (value === \textcolor{keyword}{null} || value.charAt(0) === \textcolor{charliteral}{'-\/'}) \{}
\DoxyCodeLine{                        \textcolor{keywordflow}{throw} \textcolor{keyword}{new} Error( util.format(\textcolor{stringliteral}{'The command-\/line option "\%s" requires a value.'}, name) );}
\DoxyCodeLine{                    \}}
\DoxyCodeLine{                \}}
\DoxyCodeLine{                \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{                    value = \textcolor{keyword}{true};}
\DoxyCodeLine{                \}}
\DoxyCodeLine{}
\DoxyCodeLine{                \textcolor{comment}{// skip ignored options now that we've consumed the option text}}
\DoxyCodeLine{                \textcolor{keywordflow}{if} (option.ignore) \{}
\DoxyCodeLine{                    \textcolor{keywordflow}{continue};}
\DoxyCodeLine{                \}}
\DoxyCodeLine{}
\DoxyCodeLine{                \textcolor{keywordflow}{if} (option.longName \&\& shortName) \{}
\DoxyCodeLine{                    name = option.longName;}
\DoxyCodeLine{                \}}
\DoxyCodeLine{}
\DoxyCodeLine{                \textcolor{keywordflow}{if} (typeof option.coercer === \textcolor{stringliteral}{'function'}) \{}
\DoxyCodeLine{                    value = option.coercer(value);}
\DoxyCodeLine{                \}}
\DoxyCodeLine{}
\DoxyCodeLine{                \textcolor{comment}{// Allow for multiple options of the same type to be present}}
\DoxyCodeLine{                \textcolor{keywordflow}{if} (option.canHaveMultiple \&\& hasOwnProp.call(result, name)) \{}
\DoxyCodeLine{                    \textcolor{keyword}{const} val = result[name];}
\DoxyCodeLine{}
\DoxyCodeLine{                    \textcolor{keywordflow}{if} (val instanceof Array) \{}
\DoxyCodeLine{                        val.push(value);}
\DoxyCodeLine{                    \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{                        result[name] = [val, value];}
\DoxyCodeLine{                    \}}
\DoxyCodeLine{                \}}
\DoxyCodeLine{                \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{                    result[name] = value;}
\DoxyCodeLine{                \}}
\DoxyCodeLine{            \}}
\DoxyCodeLine{            \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{                result.\_.push(arg);}
\DoxyCodeLine{            \}}
\DoxyCodeLine{        \}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{module.exports = \mbox{\hyperlink{classArgParser}{ArgParser}};}
\end{DoxyCodeInclude}
 